# ClassLoader
_(Translated by Levviata to American English using DeepL, this translation is very crude and might not be correct, beware!)_

A class file is a common way of storing the binary data of a class, and we need to use a ClassLoader to load it into memory, validate it, parse it, initialize it, and create `java.lang.Class` instances in the process.  
In a typical Java Virtual Machine Hotspot, `Class` instances and `String` constants are stored in the Heap and the Metadata of the class is stored in the Metaspace.

## Class loading process
The class loading process can be divided into three steps: loading, linking, and initialization.
### Loading
Loading is the most important step in the class loading process, and the majority of CoreMod modifications to class files are made in this step.  
First, the ClassLoader looks for the binary data of the class based on the given class name, which may be the class file on disk or the binary data generated by the code. Custom ClassLoaders often override the ``findClass`` method to find this data in order to modify the class or customize the class from sources other than the ClassPath. for class modifications or custom class sources other than ClassPath.  
It then stores it in the method area, and finally creates a `Class` instance as an access point to the method area. The `Class` instance for each class needs to be properly cached in the ClassLoader, and existing `Class` instances should be returned when attempting to load an existing class, so that each class is loaded at most once in a single ClassLoader.
### Linking
Linking can also be divided into three steps: validation, preparation, and parsing.
The first step is to validate the file format, metadata, and bytecode, then to allocate memory for static variables and to give default values using various types of zeros, and finally to replace symbolic references with direct references.
### Initialization
Static variable initialization assignments and `static` code blocks are compiled into the `<clinit>` method, which is called during the initialization phase.  
If the ClassLoader implementation is guaranteed to be loaded at most once per class through proper caching, it is also guaranteed that class initialization will be performed at most once.

## Biparental Delegation Model
The two-parent delegation model simply means that when a ClassLoader is asked to load a class, it first asks its parent class if it can load it, and then tries to load it itself if the parent class can't be loaded.  
In a typical Hotspot Java 8 virtual machine, there is an `AppClassLoader` for loading user classes, an `ExtClassLoader` for loading platform classes, and a `BootstrapLoader` for loading system classes, with the latter having higher priority than the former.  
However, the ClassLoader used to load Java programs is supposed to be transparent to the developer, and the implementation of ClassLoaders may change from time to time; for example, Java 9 no longer uses `URLClassLoader` as the type of `AppClassLoader`, and `ExtClassLoader` is replaced by PlatformClassLoader', and we will inevitably encounter errors in program development if we stick to the specific implementation. We should pay attention to the fact that application classes are loaded by multiple ClassLoaders using a biparental delegation model, and use this model properly in custom ClassLoaders. It is not recommended to override the `loadClass` method, which is a concrete implementation of the biparental delegation model.  
The biggest advantage of the two-parent delegation model is that it guarantees that the ClassLoader does its job, and greatly avoids misloading and duplication of classes.

## Customizing ClassLoader
With a brief introduction to class loading, we understand the basic class loading process and can extend the basic ClassLoader to implement a custom ClassLoader.  
Custom ClassLoaders are the basis for ModLauncher and LaunchWrapper to dynamically modify Minecraft.  
Custom ClassLoaders are generally used for the following purposes:
- Dynamically modifying classes (commonly used by CoreMod)
- Dynamically loading classes (e.g. dynamically decrypting classes, loading network classes)
- Isolating loaded classes (e.g. ModLauncher isolates CoreMod from Minecraft to prevent improper loading of classes)

A custom ClassLoader, which inherits from the `ClassLoader` class or one of its subclasses (e.g. `URLClassLoader`), typically overrides one or more of the following methods:
- `findClass`, this method receives a class name, you need to find this class and return the corresponding `Class` object, again emphasize the need to do a good job of caching, do not repeat the loading of the class
- `loadClass`, this method receives a class name and needs to load the class and return the corresponding `Class` object, also re-emphasizes the need to implement the two-parent delegation pattern.

It is recommended to override `findClass` instead of `loadClass`, as the former only needs to finish finding the class binary data and `defineClass`, while the latter needs to properly handle the biparental delegation model.
